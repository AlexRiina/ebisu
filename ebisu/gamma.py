from math import nan, log, pi, sin, exp, sqrt, pow
g = 7
p = [
    0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313,
    -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6,
    1.5056327351493116e-7
]

g_ln = 607 / 128.0
p_ln = [
    0.99999999999999709182, 57.156235665862923517, -59.597960355475491248, 14.136097974741747174,
    -0.49191381609762019978, 0.33994649984811888699e-4, 0.46523628927048575665e-4,
    -0.98374475304879564677e-4, 0.15808870322491248884e-3, -0.21026444172410488319e-3,
    0.21743961811521264320e-3, -0.16431810653676389022e-3, 0.84418223983852743293e-4,
    -0.26190838401581408670e-4, 0.36899182659531622704e-5
]

HALF_LOG_2_PI = .5 * log(2 * pi)
SQRT_2_PI = sqrt(2 * pi)


# Spouge approximation (suitable for large arguments)
def gammaln(z):
  if (z < 0):
    return nan
  x = p_ln[0]
  for i in range(len(p_ln) - 1, 0, -1):
    x += p_ln[i] / (z + i)
  t = z + g_ln + 0.5
  return HALF_LOG_2_PI + (z + .5) * log(t) - t + log(x) - log(z)


def gamma(z):
  if (z < 0.5):
    return pi / (sin(pi * z) * gamma(1 - z))
  elif (z > 100):
    return exp(gammaln(z))
  else:
    z -= 1
    x = p[0]
    for i in range(1, g + 2):
      x += p[i] / (z + i)
    t = z + g + 0.5
    return SQRT_2_PI * pow(t, z + 0.5) * exp(-t) * x
